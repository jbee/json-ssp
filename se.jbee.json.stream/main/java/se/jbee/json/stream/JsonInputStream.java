package se.jbee.json.stream;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UTFDataFormatException;
import java.io.UncheckedIOException;
import java.util.PrimitiveIterator;
import java.util.function.IntSupplier;

/**
 * The common low-level JSON input stream reader API.
 *
 * <p>This API is code-point based but makes the distinction between ASCII range characters and
 * those that might be any code-point. This addresses the fact that JSON only uses ASCII range
 * characters except within JSON strings as they occur for member names or string values.
 *
 * <p>This interfaces main role is that of an adapter to any form of underlying JSON input. This
 * adopter interface has only two simple methods that need to be implemented which makes it much
 * easier to adopt different underlying input sources so that they become usable as input for the
 * {@link JsonParser}.
 *
 * @see JsonParser
 */
public interface JsonInputStream {

  /**
   * Only called outside JSON strings.
   *
   * <p>Any non ASCII character in the input must mean the input is not a valid JSON document.
   *
   * <p>There is no {@code peekCodePoint} equivalent as it is not needed to conveniently parse JSON.
   *
   * <p>Like {@link #read()} this method has to check if the next code-point is indeed in ASCII
   * range or otherwise return the found code-point.
   *
   * <p>The two main reasons JSON grammar is inconvenient (not impossible) to parse without being
   * able to look ahead at least 1 character are:
   *
   * <ul>
   *   <li>end of a number can first be identified when a non number character is found
   *   <li>the closing square bracket of an empty array {@code []} is found where otherwise any JSON
   *       value as array element can occur. To find which case it is one has to check for the
   *       closing square bracket without consuming it so reading a value using recursion does not
   *       miss the first character of the value.
   * </ul>
   *
   * @return reads next character without consuming it, for a valid JSON document the character
   *     should be in ASCII range, -1 for end of input
   */
  int peek();

  /**
   * Only called outside JSON strings.
   *
   * <p>Any non ASCII character in the input must mean the input is not a valid JSON document.
   *
   * <p>The only difference to {@link #readCodePoint()} is that when this is called only ASCII
   * characters are expected.
   *
   * <p>The distinction of this method and {@link #readCodePoint()} can be used by implementations
   * to optimize. For encodings like UTF-8 it should be enough to read a single byte. But readers
   * have to check that this is indeed an ASCII byte. If not, they should return the code-point
   * found (for the error message generated by the caller).
   *
   * @return reads and consumes all bytes of the next character code point considering character
   *     encoding, for a valid JSON document the character should be in ASCII range, -1 for end of
   *     input
   */
  default int read() {
    return readCodePoint();
  }

  /**
   * Only called within a JSON string (member name or string value)
   *
   * @return reads and consumes all bytes of the next character code point considering character
   *     encoding, -1 for end of input
   */
  int readCodePoint();

  static JsonInputStream of(String json) {
    return of(json.codePoints().iterator());
  }

  static JsonInputStream of(PrimitiveIterator.OfInt json) {
    return of(() -> json.hasNext() ? json.nextInt() : -1);
  }

  static JsonInputStream of(IntSupplier json) {
    class IntSupplierJsonInputStream implements JsonInputStream {
      final IntSupplier json;
      int next;
      boolean peeked;

      IntSupplierJsonInputStream(IntSupplier json) {
        this.json = json;
      }

      @Override
      public final int peek() {
        readNextIfNeeded();
        return next;
      }

      @Override
      public final int readCodePoint() {
        readNextIfNeeded();
        peeked = false;
        return next;
      }

      void readNextIfNeeded() {
        if (!peeked) next = json.getAsInt();
        peeked = true;
      }
    }
    return new IntSupplierJsonInputStream(json);
  }

  static JsonInputStream of(byte[] utf8Json) {
    return of(new ByteArrayInputStream(utf8Json));
  }

  static JsonInputStream of(InputStream utf8Json) {
    return of(utf8Json, 4096);
  }

  static JsonInputStream of(InputStream utf8Json, int bufferSize) {
    class Utf8InputStreamJsonInputStream implements JsonInputStream {

      final InputStream utf8Json;
      final byte[] buffer;

      int offset;
      int pos;

      Utf8InputStreamJsonInputStream(InputStream utf8Json, int size) {
        this.utf8Json = utf8Json;
        this.buffer = new byte[size];
        pos = size;
      }

      @Override
      public int peek() {
        buffer();
        return buffer[pos];
      }

      @Override
      public int read() {
        buffer();
        return buffer[pos++];
      }

      @Override
      public int readCodePoint() {
        buffer();
        int b1 = buffer[pos++];
        if (b1 >= 0) return b1;
        buffer();
        int b2 = buffer[pos++];
        if ((b1 & 0b1111_0000) == 0b1111_0000) {
          // 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
          buffer();
          int b3 = buffer[pos++];
          buffer();
          int b4 = buffer[pos++];
          return (b1 & 0b0000_0111) << 18
              | (b2 & 0b0011_1111) << 12
              | (b3 & 0b0011_1111) << 6
              | (b4 & 0b0011_1111);
        }
        if ((b1 & 0b1110_0000) == 0b1110_0000) {
          // 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx
          buffer();
          int b3 = buffer[pos++];
          return (b1 & 0b0000_1111) << 12 | (b2 & 0b0011_1111) << 6 | (b3 & 0b0011_1111);
        }
        if ((b1 & 0b1100_0000) == 0b1100_0000) {
          // 2 bytes, 11 bits: 110xxxxx 10xxxxxx
          return (b1 & 0b0001_1111) << 6 | (b2 & 0b0011_1111);
        }
        // none of the above :(
        throw new UncheckedIOException(
            new UTFDataFormatException(
                "Not a valid UTF-8 byte at byte position: " + (offset - 1) * buffer.length + pos));
      }

      private void buffer() {
        if (pos < buffer.length) return;
        try {
          int len = utf8Json.read(buffer, 0, buffer.length);
          if (len < buffer.length) buffer[len] = -1; // mark end
          offset++;
          pos = 0;
        } catch (IOException e) {
          throw new UncheckedIOException(e);
        }
      }
    }
    return new Utf8InputStreamJsonInputStream(utf8Json, bufferSize);
  }
}
