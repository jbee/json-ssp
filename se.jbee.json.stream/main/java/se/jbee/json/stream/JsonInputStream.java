package se.jbee.json.stream;

import java.util.PrimitiveIterator;
import java.util.function.IntSupplier;

/**
 * The common low-level JSON input stream reader API.
 *
 * <p>This API is code-point based but makes the distinction between ASCII range characters and
 * those that might be any code-point. This addresses the fact that JSON only uses ASCII range
 * characters except within JSON strings as they occur for member names or string values.
 *
 * <p>This interfaces main role is that of an adapter to any form of underlying JSON input. This
 * adopter interface has only two simple methods that need to be implemented which makes it much
 * easier to adopt different underlying input sources so that they become usable as input for the
 * {@link JsonParser}.
 *
 * @see JsonParser
 */
public interface JsonInputStream {

  /**
   * Only called outside JSON strings.
   *
   * <p>Any non ASCII character in the input must mean the input is not a valid JSON document.
   *
   * <p>There is no {@code peekCodePoint} equivalent as it is not needed to conveniently parse JSON.
   *
   * <p>Like {@link #read()} this method has to check if the next code-point is indeed in ASCII
   * range or otherwise return the found code-point.
   *
   * <p>The two main reasons JSON grammar is inconvenient (not impossible) to parse without being
   * able to look ahead at least 1 character are:
   *
   * <ul>
   *   <li>end of a number can first be identified when a non number character is found
   *   <li>the closing square bracket of an empty array {@code []} is found where otherwise any JSON
   *       value as array element can occur. To find which case it is one has to check for the
   *       closing square bracket without consuming it so reading a value using recursion does not
   *       miss the first character of the value.
   * </ul>
   *
   * @return reads next character without consuming it, for a valid JSON document the character
   *     should be in ASCII range, -1 for end of input
   */
  int peek();

  /**
   * Only called outside JSON strings.
   *
   * <p>Any non ASCII character in the input must mean the input is not a valid JSON document.
   *
   * <p>The only difference to {@link #readCodePoint()} is that when this is called only ASCII
   * characters are expected.
   *
   * <p>The distinction of this method and {@link #readCodePoint()} can be used by implementations
   * to optimize. For encodings like UTF-8 it should be enough to read a single byte. But readers
   * have to check that this is indeed an ASCII byte. If not, they should return the code-point
   * found (for the error message generated by the caller).
   *
   * @return reads and consumes all bytes of the next character code point considering character
   *     encoding, for a valid JSON document the character should be in ASCII range, -1 for end of
   *     input
   */
  default int read() {
    return readCodePoint();
  }

  /**
   * Only called within a JSON string (member name or string value)
   *
   * @return reads and consumes all bytes of the next character code point considering character
   *     encoding, -1 for end of input
   */
  int readCodePoint();

  static JsonInputStream of(String json) {
    return of(json.codePoints().iterator());
  }

  static JsonInputStream of(PrimitiveIterator.OfInt json) {
    class IntStreamJsonInputStream implements JsonInputStream {
      final PrimitiveIterator.OfInt json;
      int next;
      boolean peeked;

      IntStreamJsonInputStream(PrimitiveIterator.OfInt json) {
        this.json = json;
      }

      @Override
      public int peek() {
        buffer();
        return next;
      }

      @Override
      public int readCodePoint() {
        buffer();
        peeked = false;
        return next;
      }

      private void buffer() {
        if (!peeked) next = json.hasNext() ? json.nextInt() : -1;
        peeked = true;
      }
    }
    return new IntStreamJsonInputStream(json);
  }

  static JsonInputStream of(IntSupplier json) {
    class IntSupplierJsonInputStream implements JsonInputStream {
      final IntSupplier json;
      int next;
      boolean peeked;

      IntSupplierJsonInputStream(IntSupplier json) {
        this.json = json;
      }

      @Override
      public int peek() {
        buffer();
        return next;
      }

      @Override
      public int readCodePoint() {
        buffer();
        peeked = false;
        return next;
      }

      private void buffer() {
        if (!peeked) next = json.getAsInt();
        peeked = true;
      }
    }
    return new IntSupplierJsonInputStream(json);
  }
}
